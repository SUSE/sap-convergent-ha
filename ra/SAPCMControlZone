#!/usr/bin/bash
#
# SAPCMControlZone
#
# Description: Manages SAP Convergent Mediation ControlZone
#
##############################################################################
#
# SAPCMControlZone (short mz)
# Author:       Fabian Herschel, October 2023
# Support:      linux@sap.com
# License:      GNU General Public License (GPL)
# Copyright:    (c) 2023-2024 SUSE LLC
#
# An example usage:
#      See usage() function below for more details.
#
# OCF instance parameters:
#   OCF_RESKEY_USER             - optional parameter, linux user to control the CM control-zone (default: mzadmin)
#   OCF_RESKEY_MZSHELL          - optional parameter, path to the mz-shell (default: /usr/bin/mzsh)
#                               - could take TWO paths separated by a colon. Then the first is the local, the second the central mzsh (like /usr/sap/$SID/CMP$InstNumber/CM/bin/mzsh)
#   OCF_RESKEY_SERVICE          - optional parameter, service/component name of mz (default: platform)
#
# OCF instance parameters currently not implemented:
#   OCF_RESKEY_SHUTDOWN_RETRIES - optional parameter, passed to mzsh (default: unset - use mzsh internal default)
#   OCF_RESKEY_CALL_TIMEOUT     - optional parameter, do not mix-up with RA action timeout => should be either per action type or for all actions (startup,shutdown,status))
#
# OCF instance parameters not planned to be implemented:
#   OCF_RESKEY_VERBOSE_STATUS   - optional parameter, call mz with "verbose output" (default no)
#
#######################################################################
SAPCMControlZoneVersion="0.2.7.0"
export myBASH="/usr/bin/bash"
#
# DONE: PRIO1: get RA_MZ_PLATFORM, RA_JAVA_HOME AND RA_MZ_HOME from cluster config
export RA_MZ_PLATFORM="http://localhost:9000"
export RA_JAVA_HOME="/usr/lib64/jvm/jre-17-openjdk"
export RA_MZ_HOME="/opt/cm"

export logger_pid="$$"
#
# all BASH-REGEX to be case insensitive (no case match)
shopt -s nocasematch
#
# Initialization:
#
raType="mz_"
OCF_FUNCTIONS_DIR="${OCF_FUNCTIONS_DIR:-${OCF_ROOT}/lib/heartbeat}"
# shellcheck source=/dev/null
source "${OCF_FUNCTIONS_DIR}/ocf-shellfuncs"
ocf_log INFO "Version $SAPCMControlZoneVersion ($*)"
# init a minimum set of variables, if the variable are not initialized so far
OCF_SUCCESS="${OCF_SUCCESS:-0}"
#
#######################################################################
#

#
######################################################################
#
# mz-side of the RA
#

function mz_component_startup()
{
    local user="$1" component="$2" rid="$3" lid="$4" rc=0
    # DONE PRIO1: set env for variables RA_JAVA_HOME and RA_MZ_HOME
    # DONE PRIO1: output for already started component is "platform is already running" - implemented, checked with project
    # DONE PRIO1: Output like "FAILED\nStartable platform exited unexpectedly"; interpreted as ERROR
    # TODO PRIO1: Tested, but not committed API: RC==0 OK
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --user=* ) # user handling
                        user=${1#*=}
                       ;;
            --component=* ) # component name
                        component=${1#*=}
                            ;;
            --rid=* ) # resource id to log
                        rid=${1#*=}
                        ;;
            --lid=* ) # logger id to be used
                        lid=${1#*=}
                    ;;
            --mz_platform=* ) # set RA_MZ_PLATFORM for CM
                        RA_MZ_PLATFORM=${1#*=}
                        export RA_MZ_PLATFORM
                        ;;
            --java_home=* ) # set RA_JAVA_HOME for CM
                        RA_JAVA_HOME=${1#*=}
                        export RA_JAVA_HOME
                        ;;
            --mz_home=* ) # set mz_home for CM
                        RA_MZ_HOME=${1#*=}
                        export RA_MZ_HOME
                        ;;
        esac
        shift
    done
    # using option "-f" for startup following mail "Convergent Mediation SUSE HA Status 2024-04-15" from software vendor
    result=$(su -w RA_MZ_HOME,RA_MZ_PLATFORM,RA_JAVA_HOME - "$user" -c "$mz_shell_central startup -f $component"); rc_call="$?"
    # DONE: PRIO2: Try to get rid of "grep" (bash-regmap)
    regex_starting="Starting $component\.*done."
    regex_already="$component is already running"
    if [[ ( "$result" =~ $regex_starting ) || ( "$result" =~ $regex_already ) ]]; then
        logger --id="$lid" -t "SAPCMControlZone($rid)" "INFO: mzsh ($mz_shell_central) got rc_call=$rc_call"
    else
        logger --id="$lid" -t "SAPCMControlZone($rid)" "INFO: mzsh ($mz_shell_central) got rc_call=$rc_call; result=$result"
    fi
    return "$rc"
}
export -f mz_component_startup

function mz_component_shutdown()
{
    local user="mzadmin" component="platform" rid="n/a" lid="$$" rc=0 RA_JAVA_HOME="" RA_MZ_HOME="" RA_MZ_PLATFORM=""
    # DONE PRIO1: set env for variables RA_JAVA_HOME and RA_MZ_HOME
    # TODO PRIO1: How to treat output like "Shutting down platform...\nShutdown failed. Trying kill instead.\ndone."
    # DONE PRIO1: How to treat output with unequal 3 dots (Shutting down platform....done.)
    # DONE PRIO1: Output fror already stopped component is "<component> is not running"
    # TODO PRIO1: Output like "Starting ui...FAILED"
    # TODO PRIO1: Output like "platfoam: no such server process"
    # TODO PRIO1: Tested, but not committed API: RC==0 OK
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --user=* ) # user handling
                        user=${1#*=}
                       ;;
            --component=* ) # component name
                        component=${1#*=}
                            ;;
            --rid=* ) # resource id to log
                        rid=${1#*=}
                        ;;
            --lid=* ) # logger id to be used
                        lid=${1#*=}
                    ;;
            --mz_platform=* ) # set RA_MZ_PLATFORM for CM
                        RA_MZ_PLATFORM=${1#*=}
                        export RA_MZ_PLATFORM
                        ;;
            --java_home=* ) # set RA_JAVA_HOME for CM
                        RA_JAVA_HOME=${1#*=}
                        export RA_JAVA_HOME
                        ;;
            --mz_home=* ) # set mz_home for CM
                        RA_MZ_HOME=${1#*=}
                        export RA_MZ_HOME
                        ;;
        esac
        shift
    done
    result=$(su -w RA_MZ_HOME,RA_MZ_PLATFORM,RA_JAVA_HOME - "$user" -c "$mz_shell_central shutdown $component"); rc_call="$?"
    regex_shuttingdown="Shutting down $component\.*done."
    regex_notrunning="$component is not running"; rc="$?"
    if [[ ( "$result" =~ $regex_shuttingdown ) || ( "$result" =~ $regex_notrunning ) ]]; then
        logger --id="$lid" -t "SAPCMControlZone($rid)" "INFO: mzsh ($mz_shell_central) got rc_call=$rc_call"
        rc=0
    else
        logger -p err --id="$lid" -t "SAPCMControlZone($rid)" "ERROR: mzsh ($mz_shell_central) got rc_call=$rc_call; result=$result"
        rc=1
    fi
    return "$rc"
}
export -f mz_component_shutdown

function mz_component_status()
{
    # TODO DONE: improved and more detailled parameter handling
    # TODO PRIO2: add --mz_shell in parameter handling
    local user="mzadmin" component="platform" rid="n/a" lid="$$" rc=0 RA_JAVA_HOME="" RA_MZ_HOME="" RA_MZ_PLATFORM="" timeout=60
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --user=* ) # user handling
                        user=${1#*=}
                       ;;
            --component=* ) # component name
                        component=${1#*=}
                            ;;
            --timeout=* ) # timeout
                        timeout=${1#*=}
                        ;;
            --rid=* ) # resource id to log
                        rid=${1#*=}
                        ;;
            --lid=* ) # logger id to be used
                        lid=${1#*=}
                    ;;
            --mz_platform=* ) # set RA_MZ_PLATFORM for CM
                        RA_MZ_PLATFORM=${1#*=}
                        export RA_MZ_PLATFORM
                        ;;
            --java_home=* ) # set RA_JAVA_HOME for CM
                        RA_JAVA_HOME=${1#*=}
                        export RA_JAVA_HOME
                        ;;
            --mz_home=* ) # set mz_home for CM
                        RA_MZ_HOME=${1#*=}
                        export RA_MZ_HOME
                        ;;
        esac
        shift
    done
    # TODO PRIO1: How to treat output like "platform is running without ..."
    # DONE PRIO1: set env for variables RA_JAVA_HOME and RA_MZ_HOME
    # TODO PRIO1: Tested, but not committed API: status <component> does also work
    # TODO PRIO1: Tested, but not committed API: RC==0 UP, RC==1 DEGRADED; RC==2 DOWN (one or multiple), OTHER: ERROR (FATAL)
    result=$(timeout "$timeout" su -w RA_MZ_HOME,RA_MZ_PLATFORM,RA_JAVA_HOME - "$user" -c "$mz_shell_local status $component"); rc_call="$?"
    regex_isrunning="$component is running"
    regex_isnotrunning="$component is not running"
    if [[ ( "$result" =~ $regex_isrunning ) ]]; then
        logger --id="$lid" -t "SAPCMControlZone($rid)" "INFO: mzsh ($mz_shell_local) component running; got rc_call=$rc_call (RA_MZ_PLATFORM=$RA_MZ_PLATFORM)"
        rc=0
    else
        if [[ ( "$result" =~ $regex_isnotrunning ) ]]; then
            logger --id="$lid" -t "SAPCMControlZone($rid)" "INFO: mzsh ($mz_shell_local) component not running; got rc_call=$rc_call; result=$result (RA_MZ_PLATFORM=$RA_MZ_PLATFORM)"
            rc=1
        else
            logger --id="$lid" -t "SAPCMControlZone($rid)" "INFO: mzsh ($mz_shell_local) component status unclear; got rc_call=$rc_call; result=$result (RA_MZ_PLATFORM=$RA_MZ_PLATFORM)"
            rc=2
        fi
    fi
    return "$rc"
}
export -f mz_component_status

# shellcheck disable=SC2317
function mz_component_kill()
{
    # TODO DONE: improved and more detailled parameter handling
    # TODO PRIO2: add --mz_shell in parameter handling
    # TODO PRIO1: How to treat that kill outputs "platform not running" (not killing)
    #             This occures e.g. if the component is already down.
    # TODO PRIO2: maybe killing processes (with OS command kill) directly as last try?
    local user="mzadmin" component="platform" rid="n/a" lid="$$" rc=0 RA_JAVA_HOME="" RA_MZ_HOME="" RA_MZ_PLATFORM=""
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --user=* ) # user handling
                        user=${1#*=}
                       ;;
            --component=* ) # component name
                        component=${1#*=}
                            ;;
            --rid=* ) # resource id to log
                        rid=${1#*=}
                        ;;
            --lid=* ) # logger id to be used
                        lid=${1#*=}
                    ;;
            --mz_platform=* ) # set RA_MZ_PLATFORM for CM
                        RA_MZ_PLATFORM=${1#*=}
                        export RA_MZ_PLATFORM
                        ;;
            --java_home=* ) # set RA_JAVA_HOME for CM
                        RA_JAVA_HOME=${1#*=}
                        export RA_JAVA_HOME
                        ;;
            --mz_home=* ) # set mz_home for CM
                        RA_MZ_HOME=${1#*=}
                        export RA_MZ_HOME
                        ;;
        esac
        shift
    done
    # TODO PRIO1: How to treat output like "platform is running without ..."
    # DONE PRIO1: set env for variables RA_JAVA_HOME and RA_MZ_HOME
    # TODO PRIO1: Tested, but not committed API: status <component> does also work
    # TODO PRIO1: Tested, but not committed API: RC==0 UP, RC==1 DEGRADED; RC==2 DOWN (one or multiple), OTHER: ERROR (FATAL)
    result=$(su -w RA_MZ_HOME,RA_MZ_PLATFORM,RA_JAVA_HOME - "$user" -c "$mz_shell_local kill $component"); rc_call="$?"
    # TODO: which regular expression to be cheched?
    regex_tbd="TBD"
    if [[ "$result" =~ $regex_tbd ]]; then
        logger --id="$lid" -t "SAPCMControlZone($rid)" "INFO: mzsh ($mz_shell_local) got rc_call=$rc_call (RA_MZ_PLATFORM=$RA_MZ_PLATFORM)"
    else
        logger --id="$lid" -t "SAPCMControlZone($rid)" "INFO: mzsh ($mz_shell_local) got rc_call=$rc_call; result=$result (RA_MZ_PLATFORM=$RA_MZ_PLATFORM)"
    fi
    return "$rc"
}
export -f mz_component_kill

function mz_call()
{
    # TODO: 'timeout' default value (non zero), see OCF_RESKEY_CALL_TIMEOUT?
    local rc="$OCF_ERR_GENERIC" timeout=60, user="$mz_user", action="status", component="platform" call_rc=0
    while [ $# -gt 0 ]; do
        case "$1" in
            --user=* )  user=${1#*=} ;;
            --action=* )  action=${1#*=} ;;
            --timeout=* )  timeout=${1#*=} ;;
            --component=* )  component=${1#*=} ;;
        esac
        shift
    done
    case "$action" in
        status )
                export mz_shell_local mz_shell_central component user
                retry_sleep=10
                max_retry=2
                retry_count=0
                # we might need 1-2 retries, lets check if we only need to retry, if the status runs into a timeout
                # needs to switch-user to <mzadmin>
                while [[ "$retry_count" -lt "$max_retry" ]]; do
                    (( retry_count++ ))
                    # TODO PRIO1: improved and more detailled parameter handling
                    # TODO PRIO1: add also mz_shell and java_home
                    mz_component_status --user="$user" --component="$component" --mz_platform="${mz_platform}" --mz_home="${mz_home_local}" --java_home="${java_home_local}" --rid="${OCF_RESOURCE_INSTANCE}" --lid="${logger_pid}" --timeout="$timeout"; call_rc="$?"
                    case "$call_rc" in
                        0 ) ocf_log INFO "mz_call: $component is running"
                            rc="$OCF_SUCCESS"
                            break;;
                        1 ) ocf_log INFO "mz_call: $component is NOT running"
                            rc="$OCF_NOT_RUNNING";;
                        * ) ocf_log INFO "mz_call: $component is unclear (call_rc=$call_rc)"
                            rc="$OCF_ERR_GENERIC";;
                    esac
                    sleep "$retry_sleep"
                done
                ;;
        startup )
                # needs to switch-user to <mzadmin>
                retry_sleep=10
                max_retry=2
                retry_count=0
                while [[ "$retry_count" -lt "$max_retry" ]]; do
                    (( retry_count++ ))
                    if mz_component_startup --user="$user" --component="$component" --mz_platform="${mz_platform}" --mz_home="${mz_home_central}" --java_home="${java_home_central}" --rid="${OCF_RESOURCE_INSTANCE}" --lid="${logger_pid}"; then
                        ocf_log INFO "mz_call: $component is started"
                        rc="$OCF_SUCCESS"
                        break
                    else
                        ocf_log INFO "mz_call: $component is NOT started"
                        rc="$OCF_NOT_RUNNING"
                    fi
                    sleep "$retry_sleep"
                done
                ;;
        shutdown )
                # needs to switch-user to <mzadmin>
                retry_sleep=10
                max_retry=2
                retry_count=0
                while [[ "$retry_count" -lt "$max_retry" ]]; do
                    (( retry_count++ ))
                    # second try to stop mz component
                    if mz_component_shutdown --user="$user" --component="$component" --mz_platform="${mz_platform}" --mz_home="${mz_home_central}" --java_home="${java_home_central}" --rid="${OCF_RESOURCE_INSTANCE}" --lid="${logger_pid}" ; then
                        ocf_log INFO "mz_call: $component is stopped"
                        rc="$OCF_SUCCESS"
                        break
                    else
                        ocf_log INFO "mz_call: $component is still NOT stopped"
                        rc="$OCF_ERR_GENERIC"
                    fi
                    sleep "$retry_sleep"
                done
                ;;
        kill )
                # needs to switch-user to <mzadmin>
                retry_sleep=10
                max_retry=2
                retry_count=0
                while [[ "$retry_count" -lt "$max_retry" ]]; do
                    (( retry_count++ ))
                    # second try to stop mz component
                    if mz_component_kill --user="$user" --component="$component" --mz_platform="${mz_platform}" --mz_home="${mz_home_central}" --java_home="${java_home_central}" --rid="${OCF_RESOURCE_INSTANCE}" --lid="${logger_pid}" ; then
                        ocf_log INFO "mz_call: $component is stopped"
                        rc="$OCF_SUCCESS"
                        break
                    else
                        ocf_log INFO "mz_call: $component is still NOT stopped"
                        rc="$OCF_ERR_GENERIC"
                    fi
                    sleep "$retry_sleep"
                done
                ;;
        * )
                # not implemented
                rc="$OCF_ERR_UNIMPLEMENTED"
    esac
    return "$rc"
}

#
######################################################################
#
# cluster-side of the RA
#
function mz_usage()
{
    echo "usage: $0 [start|stop|monitor|meta-data|reload|methods|usage]"
}

function mz_methods()
{
    echo "start stop monitor meta-data reload methods usage"
}

function mz_init()
{
    # TODO: init variables
    mz_user="${OCF_RESKEY_USER:-mzadmin}"
    mz_path_str="${OCF_RESKEY_MZSHELL:-/usr/bin/mzsh}"
    mz_home_str="${OCF_RESKEY_MZHOME:-/opt/cm/C11/CM}"
    java_home_str="${OCF_RESKEY_JAVAHOME:-/opt/cm/C11/CM}"
    mz_platform="${OCF_RESKEY_MZPLATFORM:-http://localhost:9000}"
    regex_multivalue="^([^:]*):(.*)$"
    ## mz_shell
    # cut string into a first part and an optional second part. parts are separated by colon (':')
    if [[ "$mz_path_str" =~ $regex_multivalue ]]; then
        # found first:second
        mz_shell_local="${BASH_REMATCH[1]}"
        mz_shell_central="${BASH_REMATCH[2]}"
    else
        mz_shell_local="$mz_path_str"
        mz_shell_central="$mz_path_str"
    fi
    ## mz_home
    # cut string into a first part and an optional second part. parts are separated by colon (':')
    if [[ "$mz_home_str" =~ $regex_multivalue ]]; then
        # found first:second
        mz_home_local="${BASH_REMATCH[1]}"
        mz_home_central="${BASH_REMATCH[2]}"
    else
        mz_home_local="$mz_home_str"
        mz_home_central="$mz_home_str"
    fi
    # DONE PRIO1: also handle arraxs for java_home
    ## java_home
    # cut string into a first part and an optional second part. parts are separated by colon (':')
    if [[ "$java_home_str" =~ $regex_multivalue ]]; then
        # found first:second
        java_home_local="${BASH_REMATCH[1]}"
        java_home_central="${BASH_REMATCH[2]}"
    else
        java_home_local="$java_home_str"
        java_home_central="$java_home_str"
    fi
    # mz_search_list="/usr/bin:/usr/sap/[A-Z][A-Z0-9][A-Z0-9]/CMP[0-9][0-9]/CM/bin/"
    mz_component="${OCF_RESKEY_SERVICE:-platform}"
    # shellcheck disable=SC2034  # variable for future usage
    mz_shutdown_retries="${OCF_RESKEY_SHUTDOWN_RETRIES:+-r $OCF_RESKEY_SHUTDOWN_RETRIES}" # empty, if OCF_RESKEY_SHUTDOWN_RETRIES} is usnet, otherwise "-r $OCF_RESKEY_SHUTDOWN_RETRIES"
    # shellcheck disable=SC2034  # variable for future usage
    mz_call_timeout="${OCF_RESKEY_CALL_TIMEOUT:-60}"
}

function mz_meta_data()
{
   # shellcheck disable=SC2016
   echo '<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="SAPCMControlZone" version="$raVersion">
<version>1.1</version>
<shortdesc lang="en">Manages SAP Convergent Mediation ControlZone.</shortdesc>
<longdesc lang="en">The SAPCMControlZone RA manages SAP Convergent Mediation ControlZone services platform or UI as active/passive resources.</longdesc>
<parameters>
<parameter name="CALL_TIMEOUT" unique="0" required="0">
   <shortdesc lang="en">Currently not implemented: How long calls to the ControlZone platform can take.</shortdesc>
   <longdesc lang="en">How long calls to the ControlZone platform for checking the status can take. If you increase this timeout, you should also adjust the operation timeouts of your Linux cluster resources.</longdesc>
    <content type="string" default="60" />
</parameter>
<parameter name="JAVAHOME" unique="0" required="0">
    <shortdesc lang="en">ControlZone specific JAVA_HOME directory</shortdesc>
    <longdesc lang="en">TBD</longdesc>
    <content type="string" default="TBD" />
</parameter>
<parameter name="MZHOME" unique="0" required="0">
    <shortdesc lang="en">ControlZone home directory</shortdesc>
    <longdesc lang="en">TBD</longdesc>
    <content type="string" default="TBD" />
</parameter>
<parameter name="MZPLATFORM" unique="0" required="0">
    <shortdesc lang="en">ControlZone connection URL</shortdesc>
    <longdesc lang="en">ControlZone connection URL</longdesc>
    <content type="string" default="http://localhost:9000" />
</parameter>
<parameter name="MZSHELL" unique="0" required="0">
    <shortdesc lang="en">ControlZone shell</shortdesc>
    <longdesc lang="en">Path to the CM ControlZone commandline shell to be called. Values: full path to the shell. The parameter could also take two different paths separarated by colon (:). In that case the first path must be the path of the "local" mzsh and the second must be the path of the "central/shared" mzsh. Format: PATH-LOCAL:PATH-CENTRAL</longdesc>
    <content type="string" default="/usr/bin/mzsh" />
</parameter>
<parameter name="SERVICE" unique="0" required="0">
    <shortdesc lang="en">Convergent Mediation ControlZone service to manage.</shortdesc>
    <longdesc lang="en">Convergent Mediation ControlZone service to manage. Either platform or UI.</longdesc>
    <content type="string" default="platform" />
</parameter>
<parameter name="SHUTDOWN_RETRIES" unique="0" required="0">
    <shortdesc lang="en">Number of retries to check for process shutdown. Not yet implemented.</shortdesc>
    <longdesc lang="en">Number of retries to check for process shutdown. If you increase the number of shutdown retries, you should also adjust the stop operation timeout of your Linux cluster resource.</longdesc>
    <content type="string" default="" />
</parameter>
<parameter name="USER" unique="0" required="0">
    <shortdesc lang="en">Linux user to control the CM component.</shortdesc>
    <longdesc lang="en">Linux user to control the CM component.</longdesc>
    <content type="string" default="mzadmin" />
</parameter>
<parameter name="VERBOSE_STATUS" unique="0" required="0">
    <shortdesc lang="en">Currently not implemented: Verbose status output.</shortdesc>
    <longdesc lang="en">Verbose status output.</longdesc>
    <content type="string" default="" />
</parameter>
</parameters>
<actions>
    <action name="start"   timeout="120" />
    <action name="stop"    timeout="120" />
    <action name="monitor" timeout="120" interval="120" />
    <action name="meta-data" timeout="5" />
    <action name="methods" timeout="5" />
    <action name="usage" timeout="5" />
    <action name="reload" timeout="5" />
</actions>
</resource-agent>'
}


# shellcheck disable=SC2120
function mz_check_params()
{
    local rc="$OCF_SUCCESS"
    if [[ -n "$OCF_RESKEY_USER" ]]; then
        if id "$OCF_RESKEY_USER" 1>/dev/null 2>/dev/null; then
            ocf_log INFO "User '$OCF_RESKEY_USER' exists"
        else
            ocf_log ERROR "User '$OCF_RESKEY_USER' does NOT exist"
            rc="$OCF_ERR_CONFIGURED"
        fi
    fi
    if [[ -n "$mz_shell_local" ]]; then
        if [[ -x "$mz_shell_local" ]]; then
            ocf_log INFO "mz_shell_local '$mz_shell_local' exists and is executable"
        else
            ocf_log ERROR "mz_shell_local '$mz_shell_local' either does NOT exist or is NOT executable"
            rc="$OCF_ERR_CONFIGURED"
        fi
    fi
    if [[ -n "$mz_shell_central" ]]; then
        if [[ -x "$mz_shell_central" ]]; then
            ocf_log INFO "mz_shell_central '$mz_shell_central' exists and is executable"
        else
            ocf_log ERROR "mz_shell_central '$mz_shell_central' either does NOT exist or is NOT executable"
            rc="$OCF_ERR_CONFIGURED"
        fi
    fi
# mz_home_local=
    if [[ -n "$mz_home_local" ]]; then
        if [[ -e "$mz_home_local" ]]; then
            ocf_log INFO "mz_home_local '$mz_home_local' exists"
        else
            ocf_log ERROR "mz_home_local '$mz_home_local' does NOT exist"
            rc="$OCF_ERR_CONFIGURED"
        fi
    fi
    if [[ -n "$mz_home_central" ]]; then
        if [[ -e "$mz_home_central" ]]; then
            ocf_log INFO "mz_home_central '$mz_home_central' exists"
        else
            ocf_log ERROR "mz_home_central '$mz_home_central' does NOT exist"
            rc="$OCF_ERR_CONFIGURED"
        fi
    fi
###
# java_home_local=
    if [[ -n "$java_home_local" ]]; then
        if [[ -e "$java_home_local" ]]; then
            ocf_log INFO "java_home_local '$java_home_local' exists"
        else
            ocf_log ERROR "java_home_local '$java_home_local' does NOT exist"
            rc="$OCF_ERR_CONFIGURED"
        fi
    fi
    if [[ -n "$java_home_central" ]]; then
        if [[ -e "$java_home_central" ]]; then
            ocf_log INFO "java_home_central '$java_home_central' exists"
        else
            ocf_log ERROR "java_home_central '$java_home_central' does NOT exist"
            rc="$OCF_ERR_CONFIGURED"
        fi
    fi
###
    regex_platformorui="^(platform|ui)$"
    if [[ -n "$OCF_RESKEY_SERVICE" ]]; then
        if [[ "$OCF_RESKEY_SERVICE" =~ $regex_platformorui ]]; then
            ocf_log INFO "Service '$OCF_RESKEY_SERVICE' matches list ['platform', 'ui']"
        else
            ocf_log INFO "Service '$OCF_RESKEY_SERVICE' does NOT match list ['platform', 'ui']"
            rc="$OCF_ERR_CONFIGURED"
        fi
    fi
    return "$rc"
}

function mz_validate()
{
    local rc="$OCF_SUCCESS"
    # shellcheck disable=SC2119
    mz_check_params; rc="$?"
    return "$rc"
}

function mz_start()
{
    local rc="$OCF_SUCCESS"
    mz_call --timeout=60 --action=startup --component="$mz_component" --user="$mz_user"; rc="$?"
    # TODO; map to cluster return code (OCF_*)
    return "$rc"
}

function mz_stop()
{
    local rc="$OCF_SUCCESS"
    # TODO: retry
    mz_call --timeout=60 --action=shutdown --component="$mz_component" --user="$mz_user"; rc="$?"
    # TODO; map to cluster return code (OCF_*)
    return "$rc"
}

function mz_reload()
{
    local rc="$OCF_SUCCESS"
    return "$rc"
}

function mz_monitor()
{
    local rc="$OCF_SUCCESS"
    # TODO: retry
    mz_call --timeout=60 --action=status --component="$mz_component" --user="$mz_user"; rc="$?"
    # TODO; map to cluster return code (OCF_*)
    return "$rc"
}

# function: main - main function to operate
# params:   ACTION
# globals:  OCF_*(r), ra_rc(rw), $0(r)
#
ra_rc="$OCF_SUCCESS"

if [ "$#" != "1" ]
then
    mz_usage
    exit "$OCF_ERR_ARGS"
fi

ACTION="$1"
if [ "$ACTION" = "status" ]; then
    ACTION=monitor
fi

# These operations don't require OCF parameters to be set
ocf_log INFO "begin action $ACTION"
case "$ACTION" in
    usage)          mz_usage
                    ocf_log INFO "SAPCMControlZone end action $ACTION rc=${ra_rc}"
                    exit "$OCF_SUCCESS";;
    methods)        mz_methods
                    ocf_log INFO "SAPCMControlZone end action $ACTION rc=${ra_rc}"
                    exit "$OCF_SUCCESS";;
    meta-data)      mz_meta_data
                    ocf_log INFO "SAPCMControlZone end action $ACTION rc=${ra_rc}"
                    exit "$OCF_SUCCESS";;
    notify)         # just ignore
                    ocf_log INFO "SAPCMControlZone end action $ACTION rc=${ra_rc}"
                    exit "$OCF_SUCCESS";;
    validate-all)
        mz_init
        mz_validate; ra_rc="$?"
        ocf_log INFO "end action $ACTION rc=${ra_rc}"
        exit "$ra_rc"
        ;;
esac
mz_init

# check for root user
if ! ocf_is_root
then
    ocf_log err "ACT: $0 must be run as root"
    exit "$OCF_ERR_PERM"
fi

# TODO PRIO2: Maybe add 'light' parameter check later
ra_rc="$OCF_ERR_UNIMPLEMENTED"
case "$ACTION" in
    start)
        mz_check_params
        mz_start;
        ra_rc="$?"
        ;;
    stop)
        mz_stop; ra_rc="$?";;
    monitor)
        mz_monitor; ra_rc="$?";;
    promote)
        mz_promote; ra_rc="$?";;
    demote)
        mz_demote; ra_rc="$?";;
    reload)
        mz_reload
        ra_rc="$OCF_SUCCESS";;
    validate)
        mz_validate
        ra_rc="$OCF_SUCCESS";;
    *)  # seems to be an unknown request
        "${raType}"methods
        ra_rc="$OCF_ERR_UNIMPLEMENTED"
        ;;
esac
ocf_log INFO "end action $ACTION rc=${ra_rc}"
exit "${ra_rc}"
# set ts=4 sw=4 sts=4 et
